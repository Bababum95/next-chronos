'use client';

import dayjs from 'dayjs';
import isoWeek from 'dayjs/plugin/isoWeek';
import { useState, useCallback, ReactNode, FC, useMemo } from 'react';

import { formatPeriod, calculateRange } from '@/lib/utils/time';

import { TIME_RANGES } from '../lib/constants';
import type { TimeRangeItem } from '../lib/types';

import { TimeRangeContext } from './time-range-context';

dayjs.extend(isoWeek);

/**
 * Props accepted by the TimeRangeProvider component.
 *
 * @property {ReactNode} children - The child components that will have access to the time range context.
 * @property {readonly TimeRangeItem[]} [ranges] - An optional array of time range options available for selection.
 * Defaults to a predefined set of TIME_RANGES.
 * @property {TimeRangeItem} [defaultValue] - An optional default selected time range value.
 * Defaults to the first item in the TIME_RANGES array.
 */
type Props = {
  children: ReactNode;
  ranges?: readonly TimeRangeItem[];
  defaultValue?: TimeRangeItem;
};

/**
 * Provides a context for managing and accessing a selected time range within the application.
 *
 * This provider computes the start of the range using dayjs's `startOf` method based on the current
 * selected time range value, and the end as the current Unix timestamp. It also formats the period
 * using a utility function `formatPeriod`. The context exposes the current range, available ranges,
 * start and end timestamps, a setter function to change the range, and a formatted period string.
 *
 * @param {Props} props - The props object containing children, optional ranges, and an optional defaultValue.
 * @returns {JSX.Element} The provider component wrapping its children with the TimeRangeContext.
 */
export const TimeRangeProvider: FC<Props> = ({
  children,
  ranges = TIME_RANGES,
  defaultValue = TIME_RANGES[0],
}) => {
  const [value, setValue] = useState(defaultValue);
  const [offset, setOffset] = useState(0);

  const handleChange = useCallback(
    (newValue: string) => {
      const current = ranges.find((range) => range.value === newValue);
      if (current) setValue(current);
    },
    [ranges]
  );

  const shiftRange = useCallback((direction: 'prev' | 'next') => {
    setOffset((prev) => prev + (direction === 'next' ? 1 : -1));
  }, []);

  const contextValue = useMemo(() => {
    const { start, end } = calculateRange(value, offset);

    return {
      range: value,
      ranges,
      end,
      start,
      setValue: handleChange,
      /**
       * A formatted string representing the period between start and end timestamps,
       * generated by the formatPeriod utility.
       */
      formattedPeriod: formatPeriod({ start, end }),
      /**
       * Current offset applied to the selected time range.
       */
      offset,
      /**
       * Function to shift the current time range by one unit in the specified direction.
       *
       * @param {'prev' | 'next'} direction - Direction to shift the time range.
       */
      shiftRange,
    };
  }, [value, ranges, handleChange, offset, shiftRange]);

  return <TimeRangeContext.Provider value={contextValue}>{children}</TimeRangeContext.Provider>;
};
